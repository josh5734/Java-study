## 1. 자바 상속의 특징
* '재산을 상속받았다'라는 말처럼 상속(Inheritance)은 말그대로 자식이 부모로부터 무언가를 물려받는 것이다. 자바에서도 상속이라는 개념은 '자식 클래스가 부모 클래스를 상속한다'는 식으로 이해된다.
* 클래스 상속을 위해서는 **extends**라는 키워드를 사용하는데, 아래 간단한 예시를 통해 상속을 이해해보자.
```java
// Animal.java
public class Animal{
  String name;
  
  public void setName(String name){
    this.name = name;
  }
}

// Dog.java
public class Dog extends Animal{
  public void sleep(){
    System.out.println(this.name + " zzz");
  }
  
  public static void main(String[] args){
    Dog dog = new Dog();  // 객체 생성
    dog.setName("poppy"); // 부모 클래스의 메서드 사용
    System.out.println(dog.name);
  }
}
```
* Dog 클래스에 name이라는 객체변수와 setName이라는 메서드를 만들지 않았지만 Animal 클래스를 상속받았기 때문에 그대로 사용이 가능하다. 
* 또한 sleep() 메서드처럼 부모 클래스에는 없는 기능을 자식 클래스에도 추가할 수 있다.
* 다만 부모 클래스를 상속받은 자식 클래스는 부모 클래스에 선언되어 있는 **public, protected** 변수와 메서드를 사용할 수 있다.

### IS-A 관계
* 위 예시에서 Dog 클래스는 Animal 클래스를 상속받았다. 이런 경우 Dog는 Animal에 포함되기 때문에 "개는 동물이다"라고 표현할 수 있다. 이러한 관계를 **IS-A 관계**라고 한다.
* 예전에 Upcasting, DownCasting에 대해 공부했을 때 상속 관계에 있는 클래스 간 캐스팅에 대해 정리했었다. 간단하게 다시 한 번 아래 예시를 통해 상속 관계에 있는 클래스 간 캐스팅에 대해 복습해보자.
```java
Animal Dog = new Dog(); // O
Dog dog = new Animal(); // 컴파일 오류 : 부모 클래스로 만든 객체는 자식 클래스의 자료형으로 사용 불가
```

### Object 클래스에 대해
* 자바에서 만드는 모든 클래스는 Object라는 클래스를 상속받게 되어 있다. 그 이유는 **모든 클래스에서 공통으로 포함하고 있어야 하는 기능을 제공하기 위해서다.**   
* **아래 사진에 있는 toString, equals, finalize 등의 메서드는 모든 클래스가 Object 클래스로부터 상속받아서 사용할 수 있게 된다. 그리고 대부분 이러한 메서드들은 오버라이딩(Overiding)하여 클래스의 사용 용도에 최적화시킬 수 있다.**   
<img src = "https://user-images.githubusercontent.com/61929745/113794229-05484900-9785-11eb-9f53-138b1e65a6f7.png" width = 600 height = 600>    


## 2. super 키워드
* 천천히 생각해보자. 부모 클래스가 변수 A, B를 가지고 있고 자식 클래스는 변수 C를 가지고 있다고 하자. 그리고 부모 클래스에 A, B를 초기화시키는 생성자가 있다고 하자. 그런데 우리는 자식 클래스 하나를 만들어서 사용하려고 한다. 이 때 자식도 부모의 A, B 변수를 자동으로 상속받게 될 것이다. 그러면 자식 클래스에서 이 녀석들의 초기화는 어떻게 할 것인가?? - **이게 바로 super 키워드의 필요성이다.**
* 아래 간단한 예시를 보자.
```java
public class Parent {
	public Parent(String name) {
		System.out.println("Constructor(" + name + ") of Parent class");
	}
	
	public Parent(InheritancePrint obj) {
		System.out.println("Constructor(InheritancePrint) of Parent class");
	}
	
	public void printName() {
		System.out.println("printName() of Parent class");
	}
}

public class Child extends ParentArg{
	public Child() {
		super("teemo");
		System.out.println("Default Constructor of Child class");
	}
}
----------------------------------------------------------
public class InheritancePrint {
	public static void main(String[] ar) {   
		Child ex = new Child();  
    //		Constructor(teemo) of ParentArg class 출력    
    //		Default Constructor of ChildArg class 출력
		ex.printName();          
    //		printName() of Parent class 출력
	}
}
```
* 부모 클래스는 생성자에서 String name이라는 매개변수를 받는다. 이 때는 자식 클래스에서 super()를 통해 부모 클래스의 생성자에 매개변수를 넘겨주는 것이다.
* 만약 자식 클래스 생성자에 super()를 안써주면 자바는 부모 클래스의 기본 생성자를 찾게 된다. 이 때 부모 클래스에 매개변수를 받는 생성자가 정의되어 있는데 기본 생성자가 정의되어 있지 않으면 오류가 터진다.


## 3. 메서드 오버라이딩
* **부모 클래스의 메서드는 상속받는 자식 클래스에게 전해진다. 그런데 자식 클래스에서는 이 메서드를 그대로 쓰기 싫고 변형해서 쓰기 싫다면?** 
```java
class Parent{
  void display(){System.out.println("Parent Class의 display() 메서드입니다.");}

class Child extends Parent{
  void display(){
    System.out.println("부모의 display()메서드를 오버라이딩합니다.");
    System.out.println("Child Class의 display() 메서드입니다.");
  }
}
```
* 위의 예제처럼 main을 직접 실행은 안해봤지만, 부모의 메서드를 Child가 상속받아서 변형하는 것이 가능하다.
* 하지만 무작정 오버라이딩이 다 되는 것은 아니다. **오버라이딩이란 메서드의 동작만을 재정의하는 것으로, 메서드의 선언부는 기존 메서드와 완전히 같아야 한다.** 

### Equals 오버라이딩
* 다음으로는 조금 더 자주 쓰이는 중요한 **equals 메서드 오버라이딩**에 대해 알아보자. 위에서 모든 클래스는 Objecct 클래스를 상속받는다고 했고, Object 클래스는 equals 메서드를 가지고 있다. 그렇다면 이를 상속받은 자식 클래스에서는 equals 메서드를 오버라이딩할 수 있겠다.
* Java의 Object 클래스 명세에서 기술하는 equals 메서드의 일반 규약은 다음과 같다.
  1. 반사성: null이 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환한다.
  2. 대칭성: null이 아닌 참조 x, y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환한다.
  3. 추이성: null이 아닌 참조 x, y, z가 있을 때, x.equals(y)가 참이고 y.equals(z)가 참이면 x.equals(z)도 참이어야 한다.
  4. 일관성: null이 아닌 참조 x와 y가 있을 때 equals를 통해 비교되는 정보에 변화가 없다면, 몇번 반복하더라도 같은 결과를 유지해야한다.

* 본격적인 예시를 보기 전에 equals 메서드에 대해 몇 가지 기억할 점을 짚고 넘어가자
  1. **equals 메서드는 서로 같은 객체인가?를 판별하게 해주는 메서드다.**  
  2. **equals 메서드는 객체의 동일성이 아닌, 논리적인 동일성을 비교하고자 할 때 쓴다.**
  3. **상위 클래스의 equals가 하위 클래스의 요구를 충족하지 못할 때 오버라이딩한다.**

* 아래 코드를 통해 예시를 살펴보자.
```java
public final class CaseInsensitiveString {
    private final String s;
    
    public CaseInsensitiveString(String s) {
        if (s == null)
            throw new NullPointerException();
        this.s = s;
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString)
            return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
        if (o instanceof String)
            return s.equalsIgnoreCase((String) o);
        return false;
    }
}
```
* 위 클래스의 equals 정의에는 문제가 생긴다. CaseInsensitiveString의 equals 메서드는 String 객체에 대해 알지만, String의 equals는 CaseInsensitiveString이 뭔지 모른다는 것이다. 이럴 경우 대칭성이 깨지게 된다. 이 상황을 인지하지 못하고 set, map, list 등을 이용하면 대참사가 발생할 수도 있다. CaseInsensitiveString 객체끼리 비교하거나, CaseInsensitiveString을 String쪽으로 같은지 확인할 때는 상관 없겠지만 String 객체를 CaseInsensitiveString쪽으로 같은지 equals를 하게 되면 다른 결과가 나올테니까말이다.
* 따라서 위의 코드는 equals가 String 객체와 상호작용하지 않게끔 고쳐줘야한다.
```java
@Override
public boolean equals(Object o){
  return (o instanceof CaseInsensitiveString) && ((CaseInsensitive) o).s equalsIgnoreCase(s);
```
* equals 메서드를 정의하는데는 꽤 여러가지 어려운 규칙이 존재한다. 위에서는 대칭성을 가지고 이야기를 해봤는데, 그 이외의 규칙에 대해서도 equals를 잘못 정의하는 때가 많다. 이런 부분을 주의깊게 염두하면서 용도에 맞게 equals를 정의해야겠다.




## 4. 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)


## 5. 추상 클래스


## 6. final 키워드
